<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JavaScript异步总结</title>
      <link href="/2019/07/15/JavaScript%E5%BC%82%E6%AD%A5%E6%80%BB%E7%BB%93/"/>
      <url>/2019/07/15/JavaScript%E5%BC%82%E6%AD%A5%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JavaScript与其他语言最大的不同点就在于其异步操作。在JavaScript中，有3种异步的调用方法：callbacks、Promises和async/await。其中callbacks是最为传统最为老派的方式，没有那么高效灵活，一般仅在必要时使用。Promises是现代JavaScript异步的支柱，允许在异步操作结束后再根据结果进行后续操作。async/await则是基于Promises的、同步风格的方式，具有更高的可读性。</p><p>此外，由于JavaScript的语言特性较为灵活，再加上异步操作本来就很复杂，保持一个良好的编程风格就显得格外重要。在本文的最后部分将对编码风格进行讨论。</p><p>但是在讨论这些之前，先让我们了解下JavaScript的异步操作是如何工作的，以及一些常用的异步函数之间有什么不同。</p><h2 id="JavaScript异步"><a href="#JavaScript异步" class="headerlink" title="JavaScript异步"></a>JavaScript异步</h2><h3 id="异步的概念"><a href="#异步的概念" class="headerlink" title="异步的概念"></a>异步的概念</h3><p>在编写一般的同步代码时，如果遇到比较费时的任务，比如I/O操作、网络操作或者计算量较大的函数时，程序会卡死在此处，直到相应的操作完成。这将极大地降低用户的体验。</p><p>异步正是为了解决这一问题而生的。当遇到比较费时当任务时，可以运用异步来避免原地等待，而是设置当任务完成后需要调用的函数。callbacks方法最直观地体现了这一点。这样一来，程序可以非阻塞地继续运行下去，而如果刚才的任务完成了，触发相应的事件调用对应的回调函数。</p><p>异步的概念非常直观，但是实际上手又是另外一回事了。首先我们需要了解的就是JavaScript中的异步到底是怎么运行的。</p><h3 id="JavaScript异步的原理"><a href="#JavaScript异步的原理" class="headerlink" title="JavaScript异步的原理"></a>JavaScript异步的原理</h3><p>第一个需要记住的概念是JavaScript在一般情况下都是单线程的（后来我了解到其实JavaScript是可以多线程的，但是必须是在完全不同的context中才行）。即使你的CPU是多核的，JavaScript也只能在其中一个核上运行。单线程保证了JavaScript的异步不会过于复杂，由于同一时间只有一个执行点，JavaScript也不需要锁的机制。但是也正因为如此，JavaScript的异步往往和我们一开始想象的并不一样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(i); &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码后，将输出3个3。原因在于，虽然设置了回调函数在0ms后启动，但是只有在线程空闲时，JavaScript的事件处理器才会运行。（另一个原因是这里使用了var来声明i，如果使用let则不会有问题）</p><p>基于上面的例子，我们也同样可以得出另一个容易造成困扰的结论：<code>setTimeout</code>中的第二个参数设置的时间并不能保证回调函数在这么长时间之后运行，而只是设置了一个下限。这个结论对于<code>setInterval</code>函数来说也同样适用。</p><h2 id="常用异步函数"><a href="#常用异步函数" class="headerlink" title="常用异步函数"></a>常用异步函数</h2><h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout()"></a>setTimeout()</h3><p>setTimeout的一般使用方法为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(func[, delay, [, param1, param2, ...]])</span><br></pre></td></tr></table></figure><p>代表（至少）delay毫秒之后运行func。param则是func的参数。</p><p>特别的，当delay设置为0时，代表在主线程完成之后立即调用func。</p><p>另一种常用的调用方式是递归调用，从而达到和<code>setInterval</code>函数类似的效果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">run</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Do something ...</span></span><br><span class="line">  setTimeout(run, delay);</span><br><span class="line">&#125;, delay);</span><br></pre></td></tr></table></figure><p>与<code>setInterval</code>不同的是，使用这种方式的delay不包含回调函数执行的时间，而<code>setInterval</code>中则相反。</p><p>还有一个相关的函数是<code>clearTimeout</code>，其调用方式为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clearTimeout(timeoutID);</span><br></pre></td></tr></table></figure><p>其中timeoutID是调用<code>setTimeout</code>后得到的返回值。</p><h3 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval()"></a>setInterval()</h3><p>setInterval的常用方式为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setInterval(func, delay[, param1, param2, ...]);</span><br></pre></td></tr></table></figure><p>代表每隔（至少）delay毫秒后运行func。param是func的参数。</p><p>取消<code>setInterval</code>的方法和取消<code>setTimeout</code>类似，可以采用如下方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clearInterval(intervalID);</span><br></pre></td></tr></table></figure><p>其中timeoutID是调用<code>setTimeout</code>后得到的返回值。</p><p>值得注意的是<code>clearTimeout</code>和<code>clearInterval</code>是在同一个列表里寻找要清除的entries的，所以实际上二者是可以混用的。但是为了程序的可读性，还是应该使用对应的函数。</p><h3 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame()"></a>requestAnimationFrame()</h3><p>上面两个函数的好处在于可以灵活控制delay的时间。但是在处理动画时，由于JavaScript的事件处理机制，无法保持最佳的帧数，有时甚至会掉帧。另外，由于没有进行相关的优化，当页面切换出去或者动画部分已经被滚轮移出屏幕时，相应的程序仍然会运行。</p><p><code>requestAnimationFrame</code>就是为了解决这些问题而生的。其常见的调用方法为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestAnimationFrame(func);</span><br></pre></td></tr></table></figure><p>代表在下一次重新绘制之前调用func函数。通常func的执行频率为每秒60次，但在大多数遵循W3C建议的浏览器中，func执行的频率与屏幕的刷新率相匹配。并且，为了提高性能，当<code>requestAnimationFrame</code>所在的窗口或者iframe运行在后台标签页或者是被隐藏时，<code>requestAnimationFrame</code>会被暂停调用。</p><h2 id="异步调用的不同方式"><a href="#异步调用的不同方式" class="headerlink" title="异步调用的不同方式"></a>异步调用的不同方式</h2><h3 id="callbacks"><a href="#callbacks" class="headerlink" title="callbacks"></a>callbacks</h3><p>之前写的部分使用的基本都是callbacks的方法。简单来说就是定义某个事件发生后需要调用的函数。除了上面所说的与时间有关的三个函数外，通常的使用方法为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">el.addEventListener(event, func);</span><br></pre></td></tr></table></figure><p>代表当网页上的el元素发生event事件时，调用func函数。</p><p>该方法的优点是兼容性好，所有浏览器都支持该方法。</p><p>缺点在于：</p><ul><li>太多回调会使得代码复杂且难以阅读（callback hell）。</li><li>如果要处理回调链中的错误，必须在回调链中的每个回调函数内分别处理。</li><li>无法保证按照定义的顺序进行回调。</li></ul><h3 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h3><p>Promises定义了一个异步方法及其状态。其状态包括：</p><ul><li>待定（pending），代表其刚被创建出来的状态，既不是成功也不是失败。</li><li>解决（resolved），代表异步方法已经返回。<ul><li>一个成功resolved的Promise称为fullfilled，其返回一个值作为<code>then()</code>中回调函数的参数</li><li>一个不成功的resolved被称为rejected，其返回一个错误信息作为<code>catch()</code>中捕获到的错误</li></ul></li></ul><p>pending状态只存在于Promise被创建出来时，而fullfilled<br>一个令人迷惑的点在于，这些状态和改变状态的函数的命名方式并不是一致的。到达fullfilled的状态需要使用resolve()函数，到达rejected状态则需要使用reject()函数。虽然其实resolve和reject只是Promise构造函数的两个参数（见下文），可以随意命名，但是习惯上还是使用这两个令人迷惑的名称。</p><p>得到一个Promise有两种方法，一是直接使用构造函数<code>new</code>出来，另一种是使用一般方法调用异步函数（函数定义前带有<code>async</code>的那种）。在此处重点说明第一种方法，第二种方法将在下一部分中涉及。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> timeoutPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    resolve(<span class="string">'Success!'</span>);</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>执行完上述语句后得到一个timeoutPromise，该Promise在创建时为pending状态。当2000毫秒之后，setTimeout的回调函数启动，将该Promise的状态变为fullfilled。这个状态的改变则会影响其后的<code>then</code>和<code>catch</code>的执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">timeoutPromise.then(<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(msg);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上述语句定义了当timeoutPromise的状态变为fullfilled之后要执行的函数：打印fullfilled传递的信息。</p><p>值得注意的是，如果在<code>then()</code>中的函数也返回一个Promise，那么多个<code>then</code>语句可以串联起来。而catch语句则一般放在所有的<code>then</code>语句后面。和同步语句类似，<code>finally</code>函数在这里也是可用的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">timeoutPromise</span><br><span class="line">.then(<span class="function"><span class="params">msg</span> =&gt;</span> &#123; <span class="comment">/* do something async */</span> &#125;)</span><br><span class="line">.then(<span class="function"><span class="params">ret</span> =&gt;</span> &#123; <span class="comment">/* do something */</span> &#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Error: '</span> + e.message);</span><br><span class="line">&#125;)</span><br><span class="line">.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Finished.'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>有时候，需要等待多个Promise变为fullfilled之后再进行下一步操作，这就需要用到Promise.all()函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([a, b, c]).then(<span class="function"><span class="params">values</span> =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在上述代码中，只有当<code>a</code>、<code>b</code>、<code>c</code>全部fullfilled之后才会执行<code>then</code>语句，并且在<code>then</code>语句中的函数的参数将为一个数组，分别对应的<code>a</code>、<code>b</code>、<code>c</code>中<code>resolve</code>函数的输入。而如果有任何一个Promise失败，则整个块都将变为rejected，然后进入<code>catch</code>部分。</p><h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><p><code>async</code>可以被放在函数声明之前，将函数的返回值变为Promise，而函数原来的返回值（如果有的话）将通过自动传递到then()中。该Promise将在函数内部定义的代码全部执行完毕之后，进入fullfilled状态。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">"Hello"</span> &#125;;</span><br><span class="line">hello().then(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">console</span>.log(value));</span><br></pre></td></tr></table></figure><p><code>await</code>只能在使用<code>async</code>声明的函数（异步函数）中使用。其作用是等待一个异步函数的调用完成（或者说等待返回的这个Promise的状态变为fillfilled）。并且会使得异步函数直接返回原来的返回值（而不是一个Promise）。在该异步函数执行完成之前，将不会执行<code>await</code>语句后面的部分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> greeting = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">"Hello"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">hello().then(alert);</span><br></pre></td></tr></table></figure><p>在使用<code>async</code>和<code>await</code>的函数中，异常处理将和同步代码类似，可以直接使用<code>try</code>/<code>catch</code>的方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFetch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">'coffee.jpg'</span>);</span><br><span class="line">    <span class="keyword">let</span> myBlob = <span class="keyword">await</span> response.blob();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> objectURL = URL.createObjectURL(myBlob);</span><br><span class="line">    <span class="keyword">let</span> image = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line">    image.src = objectURL;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(image);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myFetch();</span><br></pre></td></tr></table></figure><p>或者也可以使用<a href="#Promises">Promises</a>部分所描述的那样。因为<code>catch</code>函数不但能捕获Promise链中的错误，也能捕获<code>try</code>代码块中的错误。</p><p><code>async</code>/<code>await</code>方法使得异步代码阅读起来和同步代码类似。但是这种方法也有一定的缺陷。在<code>async</code>函数中，程序会在<code>await</code>处等待相关函数执行完毕再运行下一行代码。所以程序可能因为大量的Promises相继<code>await</code>和执行而变慢。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeoutPromise</span>(<span class="params">interval</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      resolve(<span class="string">"done"</span>);</span><br><span class="line">    &#125;, interval);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">timeTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> timeoutPromise(<span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">await</span> timeoutPromise(<span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">await</span> timeoutPromise(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述语句将花费大约3000毫秒来执行，因为这3个Promise必须依次被创建和等待。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">timeTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> timeoutPromise1 = timeoutPromise(<span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">const</span> timeoutPromise2 = timeoutPromise(<span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">const</span> timeoutPromise3 = timeoutPromise(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> timeoutPromise1;</span><br><span class="line">  <span class="keyword">await</span> timeoutPromise2;</span><br><span class="line">  <span class="keyword">await</span> timeoutPromise3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法则只需要约1000毫秒就能执行完毕，因为3个Promise是同时被创建的。这种使用方法和<code>Promise.all()</code>函数类似。</p><h2 id="未来计划"><a href="#未来计划" class="headerlink" title="未来计划"></a>未来计划</h2><p>未来可能会参考《JavaScript异步编程》和《编写可维护的JavaScript》增加编码风格的部分，以及对现在所写的内容做一些补充修改。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/learn/JavaScript/%E5%BC%82%E6%AD%A5" target="_blank" rel="noopener">Mozilla JavaScript Documentation</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SVN用法总结</title>
      <link href="/2019/06/25/SVN%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2019/06/25/SVN%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>这篇文章旨在较为系统地整理SVN的用法。如果读者希望快速上手，可以直接阅读<a href="#SVN生命周期">SVN生命周期部分</a>。</p><h2 id="SVN简介"><a href="#SVN简介" class="headerlink" title="SVN简介"></a>SVN简介</h2><p>SVN全称为Apache Subversion，是一个开源的版本控制系统。</p><h3 id="SVN中的一些概念"><a href="#SVN中的一些概念" class="headerlink" title="SVN中的一些概念"></a>SVN中的一些概念</h3><ul><li>Repository（源代码库）：源代码统一存放的地方。</li><li>Checkout（提取）：当你手上没有源代码的时候，你需要从repository checkout一份。</li><li>Commit（提交）：当你已经修改了代码，你就需要Commit到repository。</li><li>Update (更新)：当你已经Checkout了一份源代码， Update一下你就可以和Repository上的源代码同步，你手上的代码就会有最新的变更。</li></ul><p>日常开发的流程通常为：Update(获得最新的代码)=&gt;作出自己的修改并调试成功=&gt; Commit(大家就可以看到你的修改了) 。<br>值得注意的是，SVN管理源代码是以行为单位的。所以如果两个程序员同时修改了同一个文件，只要没有修改同一行，SVN就可以合并这两个改动。如果是同一行则会提示Conflict，需要手动解决冲突。</p><h3 id="SVN的主要功能"><a href="#SVN的主要功能" class="headerlink" title="SVN的主要功能"></a>SVN的主要功能</h3><ul><li>目录版本控制：SVN通过一个“虚拟”的版本管控文件系统增加了对目录变动的支持。</li><li>真实的版本历史：和CVS相比，支持了对目录或文件的增加（add）、删除（delete）、复制（copy）和重命名（rename）。所有新增的文件都从一个新的、干净的版本开始。</li><li>自动提交：commit是原子操作，不是全部更新就是完全不更新。</li><li>纳入版本控管的元数据：每个文件与目录所附有的属性也接受管控，如同文件内容一样。</li><li>选择不同的网络层：SVN可以作为一个扩展模块嵌入Apache HTTP服务器中；也可以使用轻量级的独立SVN服务器，并自定义通信协议。另外还支持：身份认证, 授权, 在线压缩, 以及文件库浏览等功能。</li><li>一致的数据处理方式：SVN使用二进制差异算法，所以在对二进制文件的支持和对文本文件的支持一样好。</li><li>有效分支（branch）与标签（tag）：SVN通过复制项目来建立分支和标签，类似与硬连接（hard-link），所以只会花费固定的少量时间。</li><li>Hackability：SVN没有历史包袱、便于维护。</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li>Windows：<a href="https://sourceforge.net/projects/win32svn/" target="_blank" rel="noopener">https://sourceforge.net/projects/win32svn/</a></li><li>CentOS：<code>yum install subversion</code></li><li>Ubuntu: <code>apt-get install subversion</code></li><li>MacOS：<code>brew install subversion</code>（需要先安装homebrew）</li></ul><p>其中CentOS和MacOS通常自带Subversion，可通过<code>svn --version</code>命令检查已安装版本。</p><h2 id="SVN生命周期"><a href="#SVN生命周期" class="headerlink" title="SVN生命周期"></a>SVN生命周期</h2><p>创建版本库=&gt;检出=&gt;更新=&gt;执行变更=&gt;复查变化=&gt;修复错误=&gt;解决冲突=&gt;提交更改</p><ul><li>创建版本库（create）：大多情况下只会执行一次。</li><li><a href="#SVN检出操作">检出（checkout）</a>：从版本库创建一个工作副本，作为开发者私人的工作空间。</li><li>更新（update）：讲工作副本与版本库进行同步。</li><li><a href="#SVN提交操作">执行变更（commit）</a>：对项目的编辑会被添加到待变更列表中，直到执行commit才会成为版本库的一部分。</li><li>复查变化（status）：在commit之前复查是很好的习惯，status会列出工作副本中的改动，可以使用diff来查看详细变动。</li><li><a href="#SVN版本回退">修复错误（revert）</a>：重置对工作副本的修改（部分或者全部），会销毁待变更列表并恢复工作副本到原始状态。</li><li><a href="#SVN解决冲突">解决冲突（mrege、resolve）</a>：merge会自动处理可以安全合并的部分，resolve用来帮助用户找出并处理冲突。</li><li><a href="#SVN提交操作">提交更改（commit）</a>：提交前必须讲文件/目录添加（add）到待变更列表中。通常需要提供一个注释来说明为什么进行这些改动。</li></ul><h2 id="SVN启动模式"><a href="#SVN启动模式" class="headerlink" title="SVN启动模式"></a>SVN启动模式</h2><ul><li><p>手动新建版本库目录<br><code>mkdir /opt/svn</code></p></li><li><p>使用svn命令创建版本库<br><code>svnadmin create /opt/svn/project_repo</code></p></li><li><p>使用senserve启动服务<br><code>svnserve -d -r 目录 --listen-port 端口号</code></p><ul><li><p><code>--listen-port</code>指定了svn监听端口（默认3690）</p></li><li><p><code>-r</code>决定了版本库访问的方式：</p><ul><li><p>在project_repo下为单库svnserve方式<code>svnserve -d -r /opt/svn/project_repo</code></p><figure class="highlight plain"><figcaption><span>authz配置文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[groups]</span><br><span class="line">admin=user1</span><br><span class="line">dev=user2</span><br><span class="line">[/]</span><br><span class="line">@admin=rw</span><br><span class="line">user2=r</span><br></pre></td></tr></table></figure><p>使用类似这样的URL：<code>svn://192.168.0.1/</code> 即可访问project_repo版本库</p></li><li><p>在svn下则为多库svnserve方式<code>svnserve -d -r /opt/svn</code></p><figure class="highlight plain"><figcaption><span>authz配置文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[groups]</span><br><span class="line">admin=user1</span><br><span class="line">dev=user2</span><br><span class="line">[project_repo:/]</span><br><span class="line">@admin=rw</span><br><span class="line">user2=r</span><br><span class="line"></span><br><span class="line">[project_repo01:/]</span><br><span class="line">@admin=rw</span><br><span class="line">user2=r</span><br></pre></td></tr></table></figure><p>如果此时你还用<code>[/]</code>，则表示所有库的根目录，同理，<code>[/src]</code>表示所有库的根目录下的src目录。<br>使用类似这样的URL：<code>svn://192.168.0.1/project_repo</code> 即可访问project_repo版本库。</p></li></ul></li></ul></li></ul><h2 id="配置SVN版本库"><a href="#配置SVN版本库" class="headerlink" title="配置SVN版本库"></a>配置SVN版本库</h2><p>进入<code>/opt/svn/project_repo/conf</code>目录 修改默认配置文件。</p><h3 id="svn服务配置文件svnserve-conf"><a href="#svn服务配置文件svnserve-conf" class="headerlink" title="svn服务配置文件svnserve.conf"></a>svn服务配置文件svnserve.conf</h3><p>该文件仅由一个<code>[general]</code>配置段组成。</p><figure class="highlight plain"><figcaption><span>conf/svnserve.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[general]</span><br><span class="line">anon-access = none</span><br><span class="line">auth-access = write</span><br><span class="line">password-db = /home/svn/passwd</span><br><span class="line">authz-db = /home/svn/authz</span><br><span class="line">realm = tiku</span><br></pre></td></tr></table></figure><ul><li>anon-access: 非鉴权用户访问版本库的权限。”write”表示可读可写，”read”表示只读，”none”表示无访问权限。 缺省值：read。</li><li>auth-access: 鉴权用户（authentication user）访问版本库的权限。”write”表示可读可写，”read”表示只读，”none”表示无访问权限。 缺省值：write。</li><li>authz-db: 权限配置文件名，通过该文件可以实现以路径为基础的访问控制。 除非指定绝对路径，否则文件位置为相对conf目录的相对路径。 缺省值：authz。</li><li>password-db: 用户名口令文件名。 除非指定绝对路径，否则文件位置为相对conf目录的相对路径。缺省值为passwd。</li><li>realm: 版本库的认证域，即在登录时提示的认证域名称。若两个版本库的认证域相同，建议使用相同的用户名口令数据文件。缺省值为一个UUID(Universal Unique IDentifier，全局唯一标示)。</li></ul><h3 id="用户名口令文件passwd"><a href="#用户名口令文件passwd" class="headerlink" title="用户名口令文件passwd"></a>用户名口令文件passwd</h3><p>用户名口令文件由svnserve.conf的配置项<code>password-db</code>指定，缺省为conf目录中的passwd。该文件仅由一个<code>[users]</code>配置段组成。</p><figure class="highlight plain"><figcaption><span>conf/passwd</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[users]</span><br><span class="line">admin = admin</span><br><span class="line">thinker = 123456</span><br></pre></td></tr></table></figure><p><code>[users]</code>配置段的配置行格式如下：<br><code>&lt;用户名&gt; = &lt;口令&gt;</code></p><h3 id="权限配置文件"><a href="#权限配置文件" class="headerlink" title="权限配置文件"></a>权限配置文件</h3><p>权限配置文件由svnserve.conf的配置项<code>authz-db</code>指定，缺省为conf目录中的authz。该配置文件由一个<code>[groups]</code>配置段和若干个版本库路径权限段组成。</p><figure class="highlight plain"><figcaption><span>conf/authz</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[groups]</span><br><span class="line">g_admin = admin,thinker</span><br><span class="line"></span><br><span class="line">[admintools:/]</span><br><span class="line">@g_admin = rw</span><br><span class="line">* =</span><br><span class="line"></span><br><span class="line">[test:/home/thinker]</span><br><span class="line">thinker = rw</span><br><span class="line">* = r</span><br></pre></td></tr></table></figure><p><code>[groups]</code>配置段的配置行格式如下：<br><code>&lt;用户名&gt; = &lt;口令&gt;</code></p><p>版本库路径权限段的段名格式如下：<br><code>[&lt;版本库名&gt;:&lt;路径&gt;]</code></p><p>本例是使用<code>svnserve -d -r /opt/svn</code>以多库svnserve方式启动SVN，所以URL为<code>svn://192.168.0.1/project_repo01</code>。</p><h2 id="SVN检出操作"><a href="#SVN检出操作" class="headerlink" title="SVN检出操作"></a>SVN检出操作</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn checkout svn://svn.server.com/svn/project_repo --username=user01</span><br></pre></td></tr></table></figure><p>检出成功后在当前目录下生成project_repo副本目录。</p><h2 id="SVN解决冲突"><a href="#SVN解决冲突" class="headerlink" title="SVN解决冲突"></a>SVN解决冲突</h2><ul><li><p>使用以下命令查看更改<br><code>svn diff</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Index: HelloWorld.html</span><br><span class="line">===================================================================</span><br><span class="line">--- HelloWorld.html     (revision 5)</span><br><span class="line">+++ HelloWorld.html     (working copy)</span><br><span class="line">@@ -1,2 +1 @@</span><br><span class="line">-HelloWorld! http://www.svn.com/</span><br><span class="line">+HelloWorld! http://www.svn.com/!</span><br></pre></td></tr></table></figure></li><li><p>尝试使用下面的命令来提交他的更改<br><code>svn commit -m &quot;change HelloWorld.html first&quot;</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@hostname:~/svn/project_repo01/trunk# svn commit -m "change HelloWorld.html first"</span><br><span class="line">Sending        HelloWorld.html</span><br><span class="line">Transmitting file data .svn: E160028: Commit failed (details follow):</span><br><span class="line">svn: E160028: File '/trunk/HelloWorld.html' is out of date</span><br></pre></td></tr></table></figure><p>此时，HelloWorld.html 已经被 user02 修改并提交到了仓库，所以提交失败了。<br>为了避免两人的代码被互相覆盖在提交更改之前必须先更新工作副本。</p></li><li><p>更新工作副本<br><code>svn update</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@hostname:~/svn/project_repo01/trunk# svn update</span><br><span class="line">Updating '.':</span><br><span class="line">C    HelloWorld.html</span><br><span class="line">Updated to revision 6.</span><br><span class="line">Conflict discovered in file 'HelloWorld.html'.</span><br><span class="line">Select: (p) postpone, (df) show diff, (e) edit file, (m) merge,</span><br><span class="line">        (mc) my side of conflict, (tc) their side of conflict,</span><br><span class="line">        (s) show all options: mc</span><br><span class="line">Resolved conflicted state of 'HelloWorld.html'</span><br><span class="line">Summary of conflicts:</span><br><span class="line">  Text conflicts: 0 remaining (and 1 already resolved)</span><br></pre></td></tr></table></figure><p>在上面的例子中选择了”mc”，代表以本地的文件为主。你也可以使用其选项对冲突的文件进行不同的操作。</p><p>默认是更新到最新的版本，我们也可以指定更新到哪个版本<br><code>svn update -r6</code></p></li><li><p>工作副本和仓库同步完毕后即可安全地提交<br><code>svn commit -m &quot;change HelloWorld.html second&quot;</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@hostname:~/svn/project_repo01/trunk# svn commit -m "change HelloWorld.html second"</span><br><span class="line">Sending        HelloWorld.html</span><br><span class="line">Transmitting file data .</span><br><span class="line">Committed revision 7.</span><br></pre></td></tr></table></figure></li></ul><h2 id="SVN提交操作"><a href="#SVN提交操作" class="headerlink" title="SVN提交操作"></a>SVN提交操作</h2><p>查看工作副本中的状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@hostname:~/svn/project_repo01/trunk# svn status</span><br><span class="line">?       readme</span><br></pre></td></tr></table></figure><p>此时 readme的状态为？，说明它还未加到版本控制中。<br>将文件readme加到版本控制，等待提交到版本库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@hostname:~/svn/project_repo01/trunk# svn add readme</span><br><span class="line">A         readme</span><br></pre></td></tr></table></figure><p>查看工作副本中的状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@hostname:~/svn/project_repo01/trunk# svn status</span><br><span class="line">A       readme</span><br></pre></td></tr></table></figure><p>此时 readme的状态为A,它意味着这个文件已经被成功地添加到了版本控制中。<br>为了把 readme 存储到版本库中，使用 commit -m 加上注释信息来提交。<br>如果你忽略了 -m 选项， SVN会打开一个可以输入多行的文本编辑器来让你输入提交信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@hostname:~/svn/project_repo01/trunk# svn commit -m "SVN readme."</span><br><span class="line">Adding         readme</span><br><span class="line">Transmitting file data.</span><br><span class="line">Committed revision 8.</span><br><span class="line">svn commit -m "SVN readme."</span><br></pre></td></tr></table></figure><p>现在 readme 被成功地添加到了版本库中，并且修订版本号自动增加了1。</p><h2 id="SVN版本回退"><a href="#SVN版本回退" class="headerlink" title="SVN版本回退"></a>SVN版本回退</h2><h3 id="回退未提交的修改"><a href="#回退未提交的修改" class="headerlink" title="回退未提交的修改"></a>回退未提交的修改</h3>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@hostname:~/svn/project_repo01/trunk# svn status</span><br><span class="line">M       readme</span><br></pre></td></tr></table></figure><p>  使用一下命令回退</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@hostname:~/svn/project_repo01/trunk# svn revert readme</span><br><span class="line">Reverted 'readme'</span><br></pre></td></tr></table></figure><p>  回退后的状态为</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@hostname:~/svn/project_repo01/trunk# svn status</span><br><span class="line">root@hostname:~/svn/project_repo01/trunk#</span><br></pre></td></tr></table></figure><p>  进行 revert 操作之后，readme 文件恢复了原始的状态。 revert 操作不单单可以使单个文件恢复原状， 而且可以使整个目录恢复原状。恢复目录用 -R 命令，如下</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn revert -R trunk</span><br></pre></td></tr></table></figure><h3 id="回退已提交的修改"><a href="#回退已提交的修改" class="headerlink" title="回退已提交的修改"></a>回退已提交的修改</h3><p>  为了消除一个旧版本，我们必须撤销旧版本里的所有更改然后提交一个新版本。这种操作叫做 reverse merge。<br>  首先，找到仓库的当前版本，现在是版本 22，我们要撤销回之前的版本，比如版本 21。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn merge -r 22:21 readme</span><br></pre></td></tr></table></figure><h2 id="SVN查看历史信息"><a href="#SVN查看历史信息" class="headerlink" title="SVN查看历史信息"></a>SVN查看历史信息</h2><p>通过svn命令可以根据时间或修订号去除过去的版本，或者某一版本所做的具体的修改。以下四个命令可以用来查看svn 的历史：</p><ul><li>svn log: 用来展示svn 的版本作者、日期、路径等等。</li><li>svn diff: 用来显示特定修改的行级详细信息。</li><li>svn cat: 取得在特定版本的某文件显示在当前屏幕。</li><li>svn list: 显示一个目录或某一版本存在的文件。</li></ul><h3 id="svn-log"><a href="#svn-log" class="headerlink" title="svn log"></a>svn log</h3><ul><li><p>基本使用方法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn log</span><br></pre></td></tr></table></figure><p>可以显示所有的信息。</p></li><li><p>如果只想查看某一个文件的版本修改信息，可以使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn log filename</span><br></pre></td></tr></table></figure></li><li><p>如果只希望查看特定的某两个版本之间的信息，可以加上<code>-r 6:8</code>。其中6和8分别代表开始的版本和结束的版本</p></li><li><p>如果希望得到目录的信息，加上<code>-v</code>。</p></li><li><p>如果希望显示限定N条记录的目录信息，加上<code>-l N</code>。</p></li></ul><h3 id="svn-diff"><a href="#svn-diff" class="headerlink" title="svn diff"></a>svn diff</h3><p>用来检查历史修改的详情。</p><ul><li><p>检查本地修改<br>如果不带任何参数，它将会比较你的工作文件与缓存在 .svn 的”原始”拷贝。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn diff</span><br></pre></td></tr></table></figure></li><li><p>比较工作拷贝与版本库<br>比较你的工作拷贝和版本库中版本号为 3 的文件 rule.txt。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn diff -r 3 rule.txt</span><br></pre></td></tr></table></figure></li><li><p>比较版本库与版本库<br>通过<code>-r(revision)</code>传递两个通过冒号分开的版本号，这两个版本会进行比较。<br>比较 svn 工作版本中版本号2和3的这个文件的变化。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn diff -r 2:3 rule.txt</span><br></pre></td></tr></table></figure></li></ul><h3 id="svn-cat"><a href="#svn-cat" class="headerlink" title="svn cat"></a>svn cat</h3><p>如果只是希望检查一个过去版本，不希望查看他们的区别，可使用<code>svn cat</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn cat -r 版本号 rule.txt</span><br></pre></td></tr></table></figure><p>这个命令会显示在该版本号下的该文件内容。</p><h3 id="svn-list"><a href="#svn-list" class="headerlink" title="svn list"></a>svn list</h3><p><code>svn list</code>可以在不下载文件到本地目录的情况下来察看目录中的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn list svn://192.168.0.1/project_repo</span><br></pre></td></tr></table></figure><h2 id="SVN分支"><a href="#SVN分支" class="headerlink" title="SVN分支"></a>SVN分支</h2><p>Branch 选项会给开发者创建出另外一条线路。当有人希望开发进程分开成两条不同的线路时，这个选项会非常有用。</p><p>比如项目 demo 下有两个小组，svn 下有一个 trunk 版。</p><p>由于客户需求突然变化，导致项目需要做较大改动，此时项目组决定由小组 1 继续完成原来正进行到一半的工作（某个模块），小组 2 进行新需求的开发。</p><p>那么此时，我们就可以为小组2建立一个分支，分支其实就是 trunk 版（主干线）的一个copy版，不过分支也是具有版本控制功能的，而且是和主干线相互独立的，当然，到最后我们可以通过（合并）功能，将分支合并到 trunk 上来，从而最后合并为一个项目。</p><ul><li><p>创建分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@hostname:~/svn/project_repo01#svn copy trunk/ branches/my_branch</span><br></pre></td></tr></table></figure></li><li><p>提交分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@hostname:~/svn/project_repo01#svn commit -m "add my_branch"</span><br></pre></td></tr></table></figure></li><li><p>切换分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@hostname:~/svn/project_repo01# cd branches/my_branch/</span><br></pre></td></tr></table></figure></li><li><p>提交分支中的修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@hostname:~/svn/project_repo01/branches/my_branch# svn add newfile</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@hostname:~/svn/project_repo01/branches/my_branch# svn commit -m "add newfile"</span><br></pre></td></tr></table></figure></li><li><p>合并分支<br>切换到 trunk，执行 svn update，然后将 my_branch 分支合并到 trunk 中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@hostname:~/svn/project_repo01/trunk# svn merge ../branches/my_branch/</span><br></pre></td></tr></table></figure></li><li><p>提交主干<br>将合并好的 trunk 提交到版本库中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@hostname:~/svn/project_repo01/trunk# svn commit -m "add newfile"</span><br></pre></td></tr></table></figure></li></ul><h2 id="SVN标签"><a href="#SVN标签" class="headerlink" title="SVN标签"></a>SVN标签</h2><p>版本管理系统支持 tag 选项，通过使用 tag 的概念，我们可以给某一个具体版本的代码一个更加有意义的名字。</p><p>Tags 即标签主要用于项目开发中的里程碑，比如开发到一定阶段可以单独一个版本作为发布等，它往往代表一个可以固定的完整的版本。</p><p>使用一下命令在本地工作副本创建一个 tag</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@hostname:~/svn/project_repo01# svn copy trunk/ tags/v1.0</span><br></pre></td></tr></table></figure><h2 id="TortoiseSVN的使用"><a href="#TortoiseSVN的使用" class="headerlink" title="TortoiseSVN的使用"></a>TortoiseSVN的使用</h2><p>具有图形界面的SVN。<br>由于我目前主要在Mac上工作，而且GUI的工具也比较好上手，故在此略过了。<br>如有需要可以参考<a href="https://www.runoob.com/svn/tortoisesvn-intro.html" target="_blank" rel="noopener">SVN教程</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>SVN教程：<a href="https://www.runoob.com/svn/svn-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/svn/svn-tutorial.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 版本控制 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>写在前面</title>
      <link href="/2019/06/16/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/"/>
      <url>/2019/06/16/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<p>托暑期实习的福，我终于真的开始做web开发了。这段时间在学习Vue.js框架，也还没有正式做项目，所以还比较轻松，也让我有时间去思考了很多。</p><p>这个博客是我忙里偷闲搞出来的。想过很多方案，最终还是采用了Hexo这个框架，配合git私有库自动部署到远程Nginx服务器上。其实也不复杂，只是中间踩了不少坑。不过这也让我对其中的很多方面有了更深的了解。从域名和vps提供商到git的使用，web服务器的选择以及静态网站这个趋势，太多东西要考虑，也让我意识到了还有太多东西要学习。</p><p>之所以下决心要自己搭一个博客，起因是看到了以前学长的博客。他的第一篇日志是在他刚踏入大学的时候写的，言语之间还透露出些许的稚嫩。然而现在他已经是一个黑客大牛。时间真的像有魔力一般，改变着我们。回想过去，我也还算好学，但总是太过贪心，觉得人工智能、网络安全、电子技术甚至是量子力学都很有趣，有了什么新的进展也都会去了解一番。说好听点这叫兴趣广泛，但是本质上还是这个时代的通病：焦虑。</p><p>所以真的需要一个载体，让我在这学生时代的最后一个暑假好好地沉淀一番。忘掉那些贩卖焦虑的自媒体上的快餐知识，沉静在一个领域里。</p><p>在未来比较长的一段时间里，我应该都会投身在大前端这个领域里。暑假是Vue，下学期又有Angular的课程，另外还有一些看了一半的React资料。这么多东西，这下可以在知识多海洋里尽情遨游了^_^。</p><p>Talk is cheap, show me the code.</p><h2 id="待办事项"><a href="#待办事项" class="headerlink" title="待办事项"></a>待办事项</h2><ul><li>Gzip压缩</li><li>HTTPS</li><li>重定向优化</li><li>SEO优化</li><li>友情链接</li></ul>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
